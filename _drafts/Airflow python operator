def my_sleeping_function:
    pass
    
task = PythonOperator(
        task_id='sleep_for_' + str(i),
        python_callable=my_sleeping_function,
        op_kwargs={'random_base': float(i) / 10},
        dag=dag,
    )
    
python_callable must be function name, not a string
op_kwargs must be a dic, key must a string
task_id must not have space



The call stack for python operator
```
File "/usr/share/airflow-venv/airflow/lib64/python3.6/site-packages/airflow/models/taskinstance.py", line 983, in _run_raw_task
result = task_copy.execute(context=context)
File "/usr/share/airflow-venv/airflow/lib64/python3.6/site-packages/airflow/operators/python_operator.py", line 113, in execute
return_value = self.execute_callable()
File "/usr/share/airflow-venv/airflow/lib64/python3.6/site-packages/airflow/operators/python_operator.py", line 118, in execute_callable
return self.python_callable(*self.op_args, **self.op_kwargs)
```


my_function(a, b, **c)

c= {'b':'xxxxxx'}

my_function('a', 'bbb', **c) will fail since c contains keyword b which will duplicated with positional argument b. which means when calling this funciton, python doesn't know which 
b.
Under the hook, no matter positional args or keyword arguments, they will converted into some fixed type of function definitions.

